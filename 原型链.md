### 原型与原型链相关

------
**创建对象的几种方法：**

```js
// 第一种，对象字面量
let o1 = { name: "yu" };
let o2 = new Object({ name: "yi" });
// 第二种，使用构造函数
let M = function(name) {
  this.name = name;
};
let o3 = new M("yu yi");
// 第三种，使用Object.create
let p = { name: "yu yi" };
let o4 = Object.create(p);

```

**原型、构造函数、实例、原型链：**

**instanceof 原理：**

instanceof 用来判断实例是否由属于某种类型，注意，也可以判断是否是其父类型或者祖先类型的实例。所以使用instanceof 不是很准确。如果要判断实例是否由某个构造函数直接生成，应该使用下面的代码。

实际上 instanceof 判断的是,实例的 __ proto__ 指向的原型对象 A 和 构造函数的 prototype 指向的原型对象 B ,是否在同一个原型链上。

```js
let M = function(name) {
  this.name = name;
};
let o3 = new M("yu yi");
o3.__proto__.constructor === M // 准确判断
```
**如何判断一个变量是否为数组：**

```js
const a = [];
a instanceof Array // true
Object.prototype.toString.call(a) // "[object Array]"
```


**new 运算符的工作原理：**

```JS
let obj = new M('YUI');
```

1. 创建一个空对象A，继承自构造函数的原型对象

2. 执行构造函数，并把构造函数中的 this 指向这个空对象A

3. 判断构造函数执行完后会不会返回一个新对象B，如果有，就抛出这个B，如果没有就返回之前创造的空对象A

   ```JS
   let new2 = function(func) {
     let obj = Object.create(func.prototype); // 1
     let k = func.call(obj); // 2
     if (typeof k === "object") {  // 3
       return k;
     } else {
       return obj;
     }
   };
   ```

   
